<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CPU Scheduling Gantt Chart Game</title>
<style>
body {
  font-family: "Poppins", sans-serif;
  background: radial-gradient(circle at top, #0b0b0b, #000);
  color: #eee;
  text-align: center;
  padding: 20px;
}
h1 {
  color: #00d4ff;
  text-shadow: 0 0 8px #00d4ff;
  margin-bottom: 20px;
}
.input-box {
  background: rgba(25,25,25,0.9);
  padding: 20px;
  border-radius: 12px;
  display: inline-block;
  border: 1px solid #00d4ff44;
  box-shadow: 0 0 15px rgba(0,212,255,0.2);
  margin-bottom: 25px;
}
select, input, button {
  margin: 6px;
  padding: 8px;
  border-radius: 6px;
  border: 1px solid #00d4ff55;
  background: #111;
  color: white;
}
button {
  cursor: pointer;
  background: linear-gradient(90deg,#00d4ff,#00ffaa);
  color: #000;
  font-weight: bold;
  transition: 0.3s;
}
button:hover {
  transform: scale(1.05);
  box-shadow: 0 0 10px #00ffaa77;
}
#gantt {
  margin: 20px auto;
  display: flex;
  justify-content: start;
  align-items: center;
  height: 60px;
  border: 1px solid #444;
  border-radius: 8px;
  background-color: #1b1b1b;
  overflow-x: auto;
  padding: 5px;
}
.block {
  height: 50px;
  margin: 0 2px;
  border-radius: 4px;
  color: #000;
  font-weight: bold;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  transition: transform 0.2s;
}
.block:hover {
  transform: scale(1.1);
}
#feedback {
  font-size: 18px;
  font-weight: bold;
  margin-top: 15px;
}
#finalMsg {
  font-size: 20px;
  color: #00ffaa;
  font-weight: bold;
  margin-top: 20px;
  text-shadow: 0 0 8px #00ffaa;
}
.process-selector {
  margin: 10px;
}
</style>
</head>
<body>

<h1>CPU SCHEDULING </h1>

<div class="input-box">
  <label><b>Algorithm:</b></label>
  <select id="algorithm" onchange="algorithmChanged()">
    <option value="FCFS">FCFS</option>
    <option value="SJF">SJF</option>
    <option value="SRTF">SRTF</option>
    <option value="Priority">Priority</option>
    <option value="RR">Round Robin</option>
  </select>
  <br>
  <div id="quantumDiv" style="display:none;">
    <label><b>Time Quantum: </b></label>
    <input type="number" id="quantum" value="2" min="1" max="10">
  </div>
  <br>
  <label><b>No. of Processes:</b></label>
  <input type="number" id="numProcesses" value="4" min="2" max="6">
  <br>
  <button onclick="startGame()">Generate Random Question</button>
</div>

<div id="processes"></div>
<div id="processSelector" class="process-selector"></div>
<div id="gantt"></div>
<p id="feedback"></p>
<p id="finalMsg"></p>
<button onclick="replaySimulation()" id="replayBtn" style="display:none;">â–¶ Watch Correct Gantt Chart</button>
<button onclick="checkAnswer()">Submit Gantt Chart</button>

<script>
let processes = [];
let algorithm, quantum, numProcesses;
let simulationSteps = [];
let selectedProcess = null;
let ganttBlocks = [];

function algorithmChanged(){
  const alg = document.getElementById("algorithm").value;
  document.getElementById("quantumDiv").style.display = (alg=="RR")?"inline-block":"none";
}

function startGame(){
  algorithm = document.getElementById("algorithm").value;
  quantum = parseInt(document.getElementById("quantum").value);
  numProcesses = parseInt(document.getElementById("numProcesses").value);

  // Generate random processes
  processes = [];
  const processDiv = document.getElementById("processes");
  processDiv.innerHTML = "<b>Processes:</b><br>";
  for(let i=0;i<numProcesses;i++){
    let p = {
      pid:"P"+(i+1),
      arrival: Math.floor(Math.random()*5),
      burst: Math.floor(Math.random()*7)+1,
      priority: Math.floor(Math.random()*5)+1,
      remaining:0
    };
    p.remaining = p.burst;
    processes.push(p);
    processDiv.innerHTML+=`${p.pid}: Arrival=${p.arrival}, Burst=${p.burst}, Priority=${p.priority}<br>`;
  }

  renderProcessSelector();
  renderGanttChart();
  document.getElementById("feedback").textContent="";
  document.getElementById("finalMsg").textContent="";
  document.getElementById("replayBtn").style.display="none";
  selectedProcess = null;
}

function renderProcessSelector(){
  const selDiv = document.getElementById("processSelector");
  selDiv.innerHTML="<b>Select Process:</b> ";
  processes.forEach((p,i)=>{
    const btn = document.createElement("button");
    btn.textContent=p.pid;
    btn.onclick=()=>{selectedProcess=i; highlightSelected(btn)};
    selDiv.appendChild(btn);
  });
}

function highlightSelected(btn){
  [...document.getElementById("processSelector").children].forEach(b=>b.style.border="1px solid #00d4ff");
  btn.style.border="2px solid #00ffaa";
}

function renderGanttChart(){
  const gantt = document.getElementById("gantt");
  gantt.innerHTML="";
  ganttBlocks = [];
  const totalTime = 30;
  for(let t=0;t<totalTime;t++){
    const div = document.createElement("div");
    div.className="block";
    div.style.width="40px";
    div.style.background="#111";
    div.dataset.time=t;
    div.dataset.proc="-1";
    div.textContent=t;
    div.onclick = ()=>placeProcess(div);
    gantt.appendChild(div);
    ganttBlocks.push(div);
  }
}

function placeProcess(block){
  if(selectedProcess===null) return;
  const colors = ["#111","#00ffaa","#ffaa00","#ff5555","#55ff55","#aa00ff"];
  block.dataset.proc=selectedProcess;
  block.style.background = colors[selectedProcess+1];
  block.textContent = processes[selectedProcess].pid;
}

// Compute correct Gantt chart for all algorithms
function computeGantt(){
  simulationSteps = [];
  let time=0;
  let rem = JSON.parse(JSON.stringify(processes));
  rem.forEach(p=>p.remaining=p.burst);

  if(algorithm=="FCFS"){
    rem.sort((a,b)=>a.arrival-b.arrival);
    rem.forEach(p=>{
      simulationSteps.push({pid:p.pid,start:Math.max(time,p.arrival),finish:Math.max(time,p.arrival)+p.burst});
      time = Math.max(time,p.arrival)+p.burst;
    });
  } else if(algorithm=="SJF"){
    let completed=0;
    let t=0;
    let procList = [...rem];
    while(completed<numProcesses){
      let available = procList.filter(p=>p.arrival<=t && p.remaining>0);
      if(available.length===0){ t++; continue; }
      available.sort((a,b)=>a.burst-b.burst);
      let p = available[0];
      simulationSteps.push({pid:p.pid,start:t,finish:t+p.burst});
      t+=p.burst;
      p.remaining=0;
      completed++;
    }
  } else if(algorithm=="SRTF"){
    let t=0, completed=0;
    let procList = [...rem];
    while(completed<numProcesses){
      let available = procList.filter(p=>p.arrival<=t && p.remaining>0);
      if(available.length===0){ t++; continue; }
      available.sort((a,b)=>a.remaining-b.remaining);
      let p = available[0];
      simulationSteps.push({pid:p.pid,start:t,finish:t+1});
      p.remaining-=1;
      if(p.remaining===0) completed++;
      t++;
    }
    // merge consecutive same process blocks
    let merged=[];
    simulationSteps.forEach(s=>{
      if(merged.length && merged[merged.length-1].pid===s.pid && merged[merged.length-1].finish===s.start){
        merged[merged.length-1].finish=s.finish;
      } else merged.push({...s});
    });
    simulationSteps=merged;
  } else if(algorithm=="Priority"){
    let completed=0;
    let t=0;
    let procList = [...rem];
    while(completed<numProcesses){
      let available = procList.filter(p=>p.arrival<=t && p.remaining>0);
      if(available.length===0){ t++; continue; }
      available.sort((a,b)=>a.priority-b.priority);
      let p = available[0];
      simulationSteps.push({pid:p.pid,start:t,finish:t+p.burst});
      t+=p.burst;
      p.remaining=0;
      completed++;
    }
  } else if(algorithm=="RR"){
    let t=0;
    let queue = [...rem];
    let remaining = queue.map(p=>p.remaining);
    while(remaining.some(r=>r>0)){
      for(let i=0;i<queue.length;i++){
        let p = queue[i];
        if(p.arrival>t || remaining[i]<=0) continue;
        let dur = Math.min(quantum,remaining[i]);
        simulationSteps.push({pid:p.pid,start:t,finish:t+dur});
        t+=dur;
        remaining[i]-=dur;
      }
      if(remaining.every(r=>r<=0)) break;
    }
  }

  document.getElementById("replayBtn").style.display="inline-block";
}

// Check student's answer
function checkAnswer(){
  computeGantt();

  // Build correct Gantt chart array
  const correctGantt = Array(ganttBlocks.length).fill(-1);
  simulationSteps.forEach(step=>{
    const idx = processes.findIndex(p=>p.pid==step.pid);
    for(let t=step.start;t<step.finish;t++){
      correctGantt[t] = idx;
    }
  });

  // Student Gantt
  const studentGantt = ganttBlocks.map(b=>parseInt(b.dataset.proc));

  let correct=true;
  for(let t=0;t<ganttBlocks.length;t++){
    if(studentGantt[t]!==correctGantt[t]){
      correct=false;
      ganttBlocks[t].style.border="2px solid red";
    } else {
      ganttBlocks[t].style.border="1px solid #00d4ff";
    }
  }

  const fb = document.getElementById("feedback");
  if(correct){
    fb.textContent="âœ… You solved correctly!";
  } else {
    fb.textContent="âŒ Wrong answer. You can watch simulation for correct solution.";
  }
}

// Replay simulation
async function replaySimulation(){
  renderGanttChart();
  const colors = ["#111","#00ffaa","#ffaa00","#ff5555","#55ff55","#aa00ff"];
  for(let step of simulationSteps){
    const idx = processes.findIndex(p=>p.pid==step.pid);
    for(let t=step.start;t<step.finish;t++){
      const block = ganttBlocks.find(b=>parseInt(b.dataset.time)==t);
      block.style.background = colors[idx+1];
      block.textContent=step.pid;
      await new Promise(res=>setTimeout(res,200));
    }
  }
  document.getElementById("feedback").textContent="ðŸŽ¬ Simulation Complete!";
  document.getElementById("finalMsg").textContent=`Algorithm: ${algorithm}`;
}
</script>
</body>
</html>
